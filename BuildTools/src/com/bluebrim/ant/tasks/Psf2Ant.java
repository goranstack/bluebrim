package com.bluebrim.ant.tasks;

import java.io.*;
import java.text.*;
import java.util.*;

import org.apache.tools.ant.*;


/**
 * Creates an Ant-file from a PSF-file, that checks out a project.
 * <p>
 * Parameters:<ul>
 * <li>psfFile (mandatory): PSF-file (Eclipse Project Set File).
 * <li>destFile (mandatory): File to create. File will be overwritten if it exist.  
 * <li>cvsUpdate (optional): If true the CVS-command "update" is used, otherwise "checkout".
 * False is default (i.e. "checkout").  
 * </ul>
 * <p>Example:
 * <pre>&lt;psf2ant psffile="example-with-branch.psf" destfile="out/example-with-branch.xml" /&gt;</pre>
 */
public class Psf2Ant extends Task
{
	private static final String ISO8601_FORMAT = "yyyy-MM-dd HH:mm:ss";
	
	private static final String LINE_BREAK = System.getProperty("line.separator", "\n");

	// CVS options:
	//   -P      Prune empty directories.
	//   -A      Reset any sticky tags/date/kopts.
	//   -C      Overwrite locally modified files with clean repository copies.
	//   -r rev  Update using specified revision/tag (is sticky).
	//
	// More info: http://www.cvsnt.org/wiki/CvsCommand 
	
	private static final String ANT_FILE_TEMPLATE =
		"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>" + LINE_BREAK +
		"<!-- This file have been generated by @className@ (@timeStamp@) -->" + LINE_BREAK +
		"<!-- **** Do NOT edit **** -->" + LINE_BREAK + LINE_BREAK +
		"<!-- PSF-file: @psfFile@ -->" + LINE_BREAK +
		"<!-- Destination file: @destFile@ -->" + LINE_BREAK +
		"<!-- Number of checkout tasks: @noOfCheckoutCalls@ -->" + LINE_BREAK + LINE_BREAK +
		"<project name=\"Project Checkout (@psfFileShort@)\" default=\"checkout\">" + LINE_BREAK + LINE_BREAK +
		"\t<target name=\"checkout\">" + LINE_BREAK +
		"@checkoutTasks@" +
		"\t</target>" + LINE_BREAK + LINE_BREAK +
		"\t<target name=\"tag\">" + LINE_BREAK +
		"@tagTasks@" +
		"\t</target>" + LINE_BREAK + LINE_BREAK +
		"</project>" + LINE_BREAK;

	private static final String CHECKOUT_TRUNC_TEMPLATE =
		"\t\t<mwm.checkout" + LINE_BREAK +
//		"\t\t\tcvsRoot=\"@cvsRoot@\"" + LINE_BREAK +
		"\t\t\tcommand=\"co -P -A -d @projectName@ @dir@\"" + LINE_BREAK +
		"\t\t/>" + LINE_BREAK;

	private static final String CHECKOUT_TAG_TEMPLATE =
		"\t\t<mwm.checkout" + LINE_BREAK +
//		"\t\t\tcvsRoot=\"@cvsRoot@\"" + LINE_BREAK +
		"\t\t\tcommand=\"co -P -r @tag@ -d @projectName@ @dir@\"" + LINE_BREAK +
		"\t\t/>" + LINE_BREAK;
	
	private static final String UPDATE_TRUNC_TEMPLATE =
		"\t\t<mwm.checkout" + LINE_BREAK +
//		"\t\t\tcvsRoot=\"@cvsRoot@\"" + LINE_BREAK +
		"\t\t\tcommand=\"update -P -C -d -A @projectName@\"" + LINE_BREAK +
		"\t\t/>" + LINE_BREAK;

	private static final String UPDATE_TAG_TEMPLATE =
		"\t\t<mwm.checkout" + LINE_BREAK +
//		"\t\t\tcvsRoot=\"@cvsRoot@\"" + LINE_BREAK +
		"\t\t\tcommand=\"update -P -C -d -r @tag@ @projectName@\"" + LINE_BREAK +
		"\t\t/>" + LINE_BREAK;

	private static final String TAG_TEMPLATE =
		"\t\t<mwm.tag" + LINE_BREAK +
//		"\t\t\tcvsRoot=\"@cvsRoot@\"" + LINE_BREAK +
		"\t\t\tcommand='tag -F ${buildserver.application.cvstag} \"@projectName@\"'" + LINE_BREAK +
		"\t\t/>" + LINE_BREAK;
	
	private File psfFile;
	private File destFile;
	private boolean cvsUpdate = false;


	public void setPsfFile(File psfFile)
	{
		this.psfFile = psfFile;
	}

	public void setDestFile(File destFile)
	{
		this.destFile = destFile;
	}

	public void setCvsUpdate(boolean cvsUpdate)
	{
		this.cvsUpdate = cvsUpdate;
	}
	
	public void execute() throws BuildException
	{
		if (psfFile == null)
			throw new BuildException("psffile attribute must be set.", getLocation());
		if (!psfFile.exists())
			throw new BuildException("psffile not found: " + psfFile.getAbsolutePath(), getLocation());
		if (destFile.exists() && !destFile.canWrite())
			throw new BuildException("Can not write to existing destfile: " + destFile.getAbsolutePath(), getLocation());
			
		List cvsRows = parseFile();
		writeAntFile(cvsRows);		
	}

	/** Parses PSF-file and returns CvsRow-objects. */
	private List parseFile() throws BuildException
	{
		List result = new ArrayList();
		BufferedReader in = null;
		try
		{
			in = new BufferedReader(new FileReader(this.psfFile));
			String line = null;
			while ((line = in.readLine()) != null)
			{
				CvsRow cvsRow = parseRow(line);
				if (cvsRow != null)
					result.add(cvsRow);
			}
		}
		catch (IOException e)
		{
			throw new BuildException("Error while reading psf-file: " + this.psfFile.getAbsolutePath(), getLocation()); 
		}
		finally
		{
			try { in.close(); } catch (Throwable ignored) { }
		}
	
		return result;
	}

	/**
	 * Parses specified row. Returns a CvsRow-object if row is a CVS-row and parsing successful.
	 * null is returned if row does not contain CVS-info.
	 */
	private CvsRow parseRow(String row) throws BuildException
	{
		// Example row (trunk):
		// <project reference="1.0,:pserver:leif:/home/cvs,mwm_System31/eclipse/Sanoma/SanomaXLib,XLib"/>
		// Example row (branch):
		// <project reference="1.0,:pserver:leif:/home/cvs,mwm_System31/eclipse/Sanoma/SanomaWatch,SanomaWatch,Sanoma_Release_20050519"/>		
		
		CvsRow result = null;
		row = row.trim();
		String prefix = "<project reference=\""; 
		String suffix = "\"/>";
		
		// is not CVS-row?
		if (!row.startsWith(prefix))
			return null;
	
		// get content of reference-attribute (without quotes)
		String attrContent = row;
		attrContent = replaceAll(attrContent, prefix, "");
		attrContent = replaceAll(attrContent, suffix, "");		
		 	
		// parse attribute
		try
		{
			StringTokenizer tokenizer = new StringTokenizer(attrContent, ",");
			String version = tokenizer.nextToken();
			// do not check version for now
			if (false && !version.equals("1.0"))
				throw new BuildException("Version not supported: " + row, getLocation());
			String cvsRoot = tokenizer.nextToken();
			String dir = tokenizer.nextToken();
			String projectName = tokenizer.nextToken();
			String tag = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null; 
			result = new CvsRow(cvsRoot, dir, projectName, tag);
		}	
		catch (NoSuchElementException e)
		{
			throw new BuildException("Can not parse row: " + row, getLocation());
		}
	
		return result;
	}

	/** Creates Ant-file as specified in templates and CvsRow-objects. */
	private void writeAntFile(List cvsRows) throws BuildException
	{
		StringBuffer checkoutTasks = new StringBuffer(1024);
		String checkoutTruncTemplate = this.cvsUpdate ? UPDATE_TRUNC_TEMPLATE : CHECKOUT_TRUNC_TEMPLATE;
		String checkoutTagTemplate = this.cvsUpdate ? UPDATE_TAG_TEMPLATE : CHECKOUT_TAG_TEMPLATE;		
		for (Iterator iter = cvsRows.iterator(); iter.hasNext(); )
		{
			CvsRow cvsRow = (CvsRow)iter.next();
			String checkoutTask = checkoutTruncTemplate;
			if (cvsRow.existsTag())
			{
				checkoutTask = checkoutTagTemplate;
				checkoutTask = replaceAll(checkoutTask, "@tag@", cvsRow.getTag());
			}
			checkoutTask = replaceAll(checkoutTask, "@cvsRoot@", cvsRow.getCvsRoot());
			checkoutTask = replaceAll(checkoutTask, "@dir@", cvsRow.getDir());			
			checkoutTask = replaceAll(checkoutTask, "@projectName@", cvsRow.getProjectName());			
			checkoutTasks.append(checkoutTask);
		}

		StringBuffer tagTasks = new StringBuffer(1024);
		for (Iterator iter = cvsRows.iterator(); iter.hasNext(); )
		{
			CvsRow cvsRow = (CvsRow)iter.next();
			String tagTask = TAG_TEMPLATE;
			tagTask = replaceAll(tagTask, "@projectName@", cvsRow.getProjectName());			
			tagTasks.append(tagTask);
		}
		
		String fileContent = ANT_FILE_TEMPLATE;
		fileContent = replaceAll(fileContent, "@checkoutTasks@", checkoutTasks.toString());
		fileContent = replaceAll(fileContent, "@tagTasks@", tagTasks.toString());
		fileContent = replaceAll(fileContent, "@className@", this.getClass().getName());
		fileContent = replaceAll(fileContent, "@timeStamp@", getTimeStamp());
		fileContent = replaceAll(fileContent, "@psfFile@", this.psfFile.getAbsolutePath());
		fileContent = replaceAll(fileContent, "@psfFileShort@", this.psfFile.getName());
		fileContent = replaceAll(fileContent, "@destFile@", this.destFile.getAbsolutePath());
		fileContent = replaceAll(fileContent, "@destFileShort@", this.destFile.getName());
		fileContent = replaceAll(fileContent, "@noOfCheckoutCalls@", cvsRows.size() + "");

		BufferedWriter out = null; 
		try
		{
			out = new BufferedWriter(new FileWriter(this.destFile));
			out.write(fileContent);
		}
		catch (IOException e)
		{
			throw new BuildException("Error while writing file: " + this.destFile.getAbsolutePath(), getLocation()); 
		}
		finally
		{
			try { out.close(); } catch (Throwable ignored) { }
		}			
	}

	private String getTimeStamp()
	{
		DateFormat formatter = new SimpleDateFormat(ISO8601_FORMAT);
		return formatter.format(new Date());
	}
	
	private String replaceAll(String str, String findStr, String replaceStr)
	{
		return replaceString(str, findStr, replaceStr, true);
	}
	
	private String replaceString(String str, String findStr, String replaceStr, boolean doReplaceAll)
	{
		if (str == null)
			return null;

		StringBuffer result = new StringBuffer(2 * str.length());
		int findStrLength = findStr.length();
		int currPos = 0;
		int hitPos;
		while ((hitPos = str.indexOf(findStr, currPos)) != -1)
		{
			result.append(str.substring(currPos, hitPos));
			result.append(replaceStr);
			currPos = hitPos + findStrLength;
			if (!doReplaceAll)
			{
				break;
			}
		}
		result.append(str.substring(currPos));

		return result.toString();
	}
	

// ---- Inner-class CvsRow -------------------------------------------------------------------------------------------
	/**
	 * Represents a parsed line in the PSF-file that contains CVS-info.  
	 */
	private class CvsRow
	{
		private String cvsRoot;
		private String dir;		
		private String projectName;		
		private String tag;		
		
		public CvsRow(String cvsRoot, String dir, String projectName, String tag)
		{
			this.cvsRoot = cvsRoot;
			this.dir = dir;		
			this.projectName = projectName;
			this.tag = tag;
		}

		public String getCvsRoot()
		{
			return this.cvsRoot;
		}

		public String getDir()
		{
			return this.dir;
		}

		public String getProjectName()
		{
			return this.projectName;
		}

		public boolean existsTag()
		{
			return ((tag != null) && (tag.trim().length() > 0));
		}
		
		public String getTag()
		{
			return this.tag;
		}
		
	}
	
}
